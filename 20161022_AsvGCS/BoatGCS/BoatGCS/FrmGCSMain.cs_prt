using System;
using System.Collections;//队列等
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Reflection;
using System.IO;
using System.Runtime.InteropServices; 

using GeoUtility;
using GeoUtility.GeoSystem;
using GMap.NET;
using GMap.NET.WindowsForms;
using GMap.NET.WindowsForms.Markers;
using GMap.NET.WindowsForms.ToolTips;
using System.IO.Ports;//串口
using System.Threading;//串口线程用
using BoatGCS;

namespace BoatGCS
{
    public partial class FrmGCSMain : Form
    {
        //定义一些常量
        // RS232 task
        public const byte RECV_HEAD1=0;
        public const byte RECV_HEAD2 = 1;
        public const byte RECV_LEN = 2;
        public const byte RECV_CNT=3;
        public const byte RECV_SYSID=4;
        public const byte RECV_TYPE = 5;
        public const byte RECV_DATA=6;
        public const byte RECV_CHECKSUM=7;

        //just for test receive ascii data
        public const byte RECV_NUM = 0;
        public const byte RECV_DOT = 1;
        public const byte RECV_ABC = 2;

        //通信数据包ID
        public const byte ID_GCS2AP_CMD = 0x01;
        public const byte ID_GCS2AP_WP = 0x02;
        public const byte ID_GCS2AP_LNK = 0x03;

        public const byte ID_AP2GCS_REAL = 0x11;
        public const byte ID_AP2GCS_CMD = 0x12;
        public const byte ID_AP2GCS_WP = 0x13;
        public const byte ID_AP2GCS_ACK = 0x14;

        public const byte ID_AP2GCS_AWS = 0x18;

        //设备ID
        public const byte SYSID_AP = 0x1;
        public const byte SYSID_GCS = 0xf;

        public const double TIMER_DISP=2000;//[ms] 

        public const double BEIJING_LAT=39.958436; 
        public const double BEIJING_LNG=116.309175; 
        public const double HUAINAN_LAT=32.56765; 
        public const double HUAINAN_LNG=117.00853;

        //public double onestep = 0.1;

        /// <summary>
        /// 默认航行速度
        /// </summary>
        public const int default_WP_spd = 1;//[knot]  

        //游戏杆相关
        private JoystickInterface.Joystick joystick;

        //串行通信接口相关
        //开两个串口，一个(comA)用于电台通信，一个(comB)用于铱星通信
        public static ComPortPar comAPara;
        public static ComPortPar comBPara;
        SerialPort comPortA = new SerialPort();//电台通信
        SerialPort comPortB = new SerialPort();//铱星通信
        /// <summary>
        /// used as a serial port write lock
        /// </summary>
        volatile object comASendlock = new object();
        // used for a readlock on readpacket
        volatile object comARecvlock = new object();


        int comAsendPacketCnt;//串口A发送计数
        int comArecvCount;//串口A发送计数
        int comAsendCount;//串口A发送计数

        private string[] ports;//可用串口数组
        Thread comARecvThread;//串口读线程
        Queue comArecQueue = new Queue();//接收数据线程与数据处理线程直接传递的队列
        //invoke里判断是否正在关闭串口是否正在关闭串口，执行Application.DoEvents，
        //并阻止再次invoke ,解决关闭串口时，程序假死，具体参见http://news.ccidnet.com/art/32859/20100524/2067861_4.html
        private bool comAListening = false;//是否没有执行完invoke相关操作
        private bool comAClosing = false;//是否正在关闭串口，执行Application.DoEvents，并阻止再次invoke

        //Thread comBRecvThread;
        Queue comBrecQueue = new Queue();//接收数据线程与数据处理线程直接传递的队列
        //int comBrecvCount;
        //int comBsendCount;
        //private bool comBWaitClose = false;//invoke里判断是否正在关闭串口是否正在关闭串口，执行Application.DoEvents，
        //并阻止再次invoke ,解决关闭串口时，程序假死，具体参见http://news.ccidnet.com/art/32859/20100524/2067861_4.html

        //声音相关
        System.Media.SoundPlayer _alarmSound = new System.Media.SoundPlayer(Properties.Resources.alarm);
        System.Media.SoundPlayer _didiSound = new System.Media.SoundPlayer(Properties.Resources.didi);

        //地图相关
        /// <summary>
        /// 航路规划层，用于标记设定航点和预定航线
        /// </summary>
        GMapOverlay markersOverlay;
        /// <summary>
        /// 实际飞行路径层
        /// </summary>
        GMapOverlay realRouteOverlay;
        /// <summary>
        /// 飞行器飞行动画层
        /// </summary>
        GMapOverlay realVehicleOverlay;
        /// <summary>
        /// 规划航点队列，包含了全部规划航点信息。航点0为家
        /// </summary>
        public static List<PointLatLngAlt> totalWPlist = new List<PointLatLngAlt>();

        /// <summary>
        /// 家坐标
        /// </summary>
        PointLatLng homePos = new PointLatLng();
        /// <summary>
        /// 生效航点标记
        /// </summary>
        GMapMarker actWP_marker;
        /// <summary>
        /// 航点索引
        /// </summary>
        public static int actWP_index;
        /// <summary>
        /// 当前在地图上鼠标所指的位置
        /// </summary>
        PointLatLng currentPosition = new PointLatLng();

        //List<int> groupmarkers = new List<int>();

        /// <summary>
        /// 用于计算地图上两点距离的临时坐标变量
        /// </summary>
        PointLatLngAlt tmp_point_4_calc = new PointLatLngAlt();

        /// <summary>
        /// 全局状态结构，其中包含了全部用于在整个程序中传递的状态变量或标志
        /// </summary>
        public static GBL_VAR gbl_var;

        //public static byte wpNum; 
       // WAYPOINT wp

        /// <summary>
        /// 要发送给AP的航点
        /// </summary>
        public static GCS_AP_WP gcs2ap_wp;
        /// <summary>
        /// 从AP返回的航点
        /// </summary>
        public static GCS_AP_WP ap2gcs_wp_back;
        /// <summary>
        /// 发送给AP的命令
        /// </summary>
        public static GCS_AP_CMD gcs2ap_cmd;
        /// <summary>
        /// 正在更新的命令，等更新完毕后变为gcs2ap_cmd_new发给AP
        /// </summary>
        public static GCS_AP_CMD gcs2ap_cmd_new;
        /// <summary>
        /// AP返回的GCS命令
        /// </summary>
        public static GCS_AP_CMD ap2gcs_cmd_back;
        /// <summary>
        /// 发送给AP的链路确认包
        /// </summary>
        public static GCS2AP_LNK gcs2ap_lnk;
        /// <summary>
        /// 接收到的AP实时包
        /// </summary>
        public static AP2GCS_REAL ap2gcs_real;
        /// <summary>
        /// 接收到的AP确认包
        /// </summary>
        public static AP2GCS_ACK ap2gcs_ack;
        /// <summary>
        /// 接收到的AP气象站包
        /// </summary>
        public static AP2GCS_AWS ap2gcs_aws;

        /// <summary>
        /// comA 接收到的数据包
        /// </summary>
        public static RECV_PACKET comA_recvpacket;
        /// <summary>
        /// 定时器定时计数
        /// </summary>
        public static int timerCnt;

        public FrmGCSMain()
        {
            InitializeComponent();
        }
        /// <summary>
        /// 实时数据记录文件名,按时间写文件名，保存格式为逗号分割ASCII码
        /// </summary>
        FileStream file_real = new FileStream(DateTime.Now.ToString("yyyy-MM-dd-hhmmss")+".txt", FileMode.Create);//创建一个1.txt
        //文件指针
        StreamWriter file_real_w;
        /// <summary>
        /// 写字串
        /// </summary>
        string file_real_str = "";        

        private void FrmGCSMain_Load(object sender, EventArgs e)
        {
            this.MaximumSize = this.MaximumSize;// .Size;
            this.MinimumSize = this.MinimumSize;//.Size;
            this.MaximizeBox = true;

            gbl_var.main_timer_interval = main_timer.Interval;

            //创建实时数据的保存文件
            file_real_w = new StreamWriter(file_real);

            // 查找并初始化游戏杆
            joystick = new JoystickInterface.Joystick(this.Handle);
            string[] sticks = joystick.FindJoysticks();
            if (sticks == null)
            {
                MessageBox.Show("未连接摇杆!");
                //Process.GetCurrentProcess().Kill();
                gbl_var.bJoystickInstalled = false;
            }
            else
            {
                gbl_var.bJoystickInstalled = true;
            }

            if(gbl_var.bJoystickInstalled) joystick.AcquireJoystick(sticks[0]);
        

            //地图初始化
            gMapControl.SetPositionByKeywords("Beijing,China");//先随意指定一个地图中心，等GPS定位后自动更新到实际坐标点
            //gMap.MapProvider = GMap.NET.MapProviders.AMapSateliteProvider.Instance;//初始默认采用高德卫星地图
            gMapControl.MapProvider = GMap.NET.MapProviders.AMapProvider.Instance;//初始默认采用高德地图
            statusMapProvider.Text = "高德地图";
            gMapControl.CacheLocation = @"G:\GMAP";//好像不管用???
            gMapControl.Manager.Mode = AccessMode.ServerAndCache;
            GMap.NET.GMaps.Instance.Mode = GMap.NET.AccessMode.ServerAndCache;

            //创建一个marker层，用于标记航点
            markersOverlay = new GMapOverlay("markers");
            gMapControl.Overlays.Add(markersOverlay);
            //创建一个飞行动画层，用于动态显示飞行器的飞行状态
            realVehicleOverlay = new GMapOverlay("realvehicle");
            gMapControl.Overlays.Add(realVehicleOverlay);
            //创建实时航路层，用于显示实时航线
            realRouteOverlay = new GMapOverlay("realroute");
            gMapControl.Overlays.Add(realRouteOverlay);

            //初始显示位置和地图尺寸，后面当选择"设置为家"按钮时，将直接将AP上返回的GPS坐标作为家的位置
            homePos.Lat = HUAINAN_LAT;
            homePos.Lng = HUAINAN_LNG;
            gMapControl.Position = homePos;
            gMapControl.Zoom = 16;

            //航点表中的0号航点为家坐标
            totalWPlist.Add(new PointLatLngAlt(homePos.Lat, homePos.Lng, 0.0, "H"));
            addpolygonmarker("H", homePos.Lat, homePos.Lng, 0.0, null);

            //启动主定时器，定时间隔100ms
            main_timer.Enabled = true;

            //串口初始化，但不打开
            ports = SerialPort.GetPortNames();//获取可用串口
            if (ports.Length > 0)//有串口可用
            {
                for (int i = 0; i < ports.Length; i++)
                {
                    cbxACOMPort.Items.Add(ports[i]);//下拉控件里添加可用串口
                    cbxBCOMPort.Items.Add(ports[i]);//下拉控件里添加可用串口
                }
                cbxACOMPort.SelectedIndex = 0;
                cbxBCOMPort.SelectedIndex = 0;
            }
            else//未检测到串口
            {
                statusPortAName.Text = "串口A: ";
                statusPortBName.Text = "串口B: ";
            }

            //列出常用的波特率
            cbxABaudRate.Items.Add("9600");
            cbxABaudRate.Items.Add("19200");
            cbxABaudRate.Items.Add("38400");
            cbxABaudRate.Items.Add("57600");
            cbxABaudRate.Items.Add("115200");
            cbxABaudRate.SelectedIndex = 0;

            cbxBBaudRate.Items.Add("9600");
            cbxBBaudRate.Items.Add("19200");
            cbxBBaudRate.Items.Add("38400");
            cbxBBaudRate.Items.Add("57600");
            cbxBBaudRate.Items.Add("115200");
            cbxBBaudRate.SelectedIndex = 0;

            btnPortAOpenClose.Text = "打开";
            comPortA.DataReceived += new SerialDataReceivedEventHandler(comAReceived); 
           
            //初始位置所在城市设置，用于在没有GPS采集数据时设置地图位置
            cbxBoxHomeCity.Items.Add("北京");
            cbxBoxHomeCity.Items.Add("淮南");

            //初始化参数

            //GCS2AP_CMD初始化
            //以后需要改为读参数文件进行初始化
            gcs2ap_cmd.cmd_state = 0x3;//开机自动进入测试状态
            gcs2ap_cmd.cmd_test = 0x4;//方向舵舵机输出有效
            gcs2ap_cmd.cmd_manu = 0x0;//主推进器停车
            gcs2ap_cmd.cmd_auto = 0x0;//完全自驾状态
            gcs2ap_cmd.cmd_rkt = 0x0;
            gcs2ap_cmd.cmd_mot = 0x0;
            gcs2ap_cmd.cmd_aws = 0x0;
            gcs2ap_cmd.cmd_flag = 0x1;//电台和铱星同时工作
            gcs2ap_cmd.moo_pwm = 127;//中位
            gcs2ap_cmd.mbf_pwm = 127;
            gcs2ap_cmd.rud_pwm = 127;
            gcs2ap_cmd.rud_p = 1;
            gcs2ap_cmd.rud_i = 0;
            gcs2ap_cmd.wpno = 0xff;//航点数据无效
            //系统启动时两个数据相同，后面通过对比来确定数据是否变化
            gcs2ap_cmd_new = gcs2ap_cmd;

        }
        /// <summary>
        /// 接收缓冲区尺寸
        /// </summary>
        public static int packbuflen;

        //wangbo
        public static int firstWp;

        private void comAReceived(object sender, SerialDataReceivedEventArgs e)//接收数据 中断只标志有数据需要读取，读取操作在中断外进行
        {
            int recvLen;
            int i = 0;
            byte c = 0;
            byte[] packbuf = new byte[500];//接收缓冲区
            for (i = 0; i < 500; i++) packbuf[i] = 0;

            if (comAClosing) return;//如果正在关闭，忽略操作，直接返回，尽快的完成串口监听线程的一次循环
            Thread.Sleep(50);
            if (false)
            {
                comPortA.DiscardInBuffer();//清接收缓存
            }
            else
            {
                byte[] recvBuffer;//接收缓冲区
                try
                {
                    comAListening = true;//设置标记，说明我已经开始处理数据，一会儿要使用系统UI的。
                    recvBuffer = new byte[comPortA.BytesToRead];//接收数据缓存大小
                    recvLen = comPortA.Read(recvBuffer, 0, recvBuffer.Length);//读取数据
                    comArecvCount += recvLen;

                    //此处加数据处理
                    for(i=0;i<recvLen;i++)
                    {
                        c = recvBuffer[i];
                        switch (comA_recvpacket.state)
                        {
                            case RECV_HEAD1:
                                if (c == 0xaa)
                                {
                                    comA_recvpacket.state = RECV_HEAD2;
                                    comA_recvpacket.checksum = c;
                                }
                                packbuflen = 0;
                                break;
                            case RECV_HEAD2:
                                if (c == 0x55)
                                {
                                    comA_recvpacket.state = RECV_LEN;
                                    comA_recvpacket.checksum += c;
                                }
                                else
                                {
                                    comA_recvpacket.state = RECV_HEAD1;
                                }
                                packbuflen = 0;
                                break;
                            case RECV_LEN:
                                comA_recvpacket.len = c;
                                comA_recvpacket.state = RECV_CNT;
                                comA_recvpacket.checksum += c;
                                packbuflen = 0;
                                break;
                            case RECV_CNT:
                                comA_recvpacket.cnt = c;
                                comA_recvpacket.state = RECV_SYSID;
                                comA_recvpacket.checksum += c;
                                packbuflen = 0;
                                break;
                            case RECV_SYSID:
                                comA_recvpacket.sysid = c;
                                comA_recvpacket.state = RECV_TYPE;
                                comA_recvpacket.checksum += c;
                                packbuflen = 0;
                                break;
                            case RECV_TYPE:
                                comA_recvpacket.type = c;
                                comA_recvpacket.state = RECV_DATA;
                                comA_recvpacket.checksum += c;
                                packbuflen = 0;
                                break;
                            case RECV_DATA:
                                packbuf[packbuflen] = c;                                
                                comA_recvpacket.checksum += c;
                                packbuflen++;
                                
                                if (packbuflen >= comA_recvpacket.len)
                                {
                                    comA_recvpacket.state = RECV_CHECKSUM;
                                }
                                break;
                            case RECV_CHECKSUM:
                                if (comA_recvpacket.checksum == c)
                                {
                                    if (comA_recvpacket.type == ID_AP2GCS_REAL)//AP-->GCS的实时数据
                                    {
                                        //ap2gcs_real.lng = BitConverter.ToUInt32(packbuf,0);//[度*0.00001]
                                        //ap2gcs_real.lat = BitConverter.ToUInt32(packbuf,4);//[度*0.00001]
                                        //ap2gcs_real.spd = BitConverter.ToInt16(packbuf,8);//[Knot*0.01]，实时航速
                                        //ap2gcs_real.dir = BitConverter.ToInt16(packbuf,10);//[度*0.01]，航向
                                        //ap2gcs_real.pitch = BitConverter.ToInt16(packbuf,12);//[度*0.01]，俯仰
                                        //ap2gcs_real.roll = BitConverter.ToInt16(packbuf,14);//[度*0.01]，滚转
                                        //ap2gcs_real.yaw = BitConverter.ToInt16(packbuf,16);//[度*0.01]，偏航
                                        //ap2gcs_real.moo_pwm = packbuf[18];//主电机启停舵机PWM 0-255
                                        //ap2gcs_real.mbf_pwm = packbuf[19];//主电机前进后退舵机PWM 0-255
                                        //ap2gcs_real.rud_pwm = packbuf[20];//方向舵舵机PWM 0-255
                                        //ap2gcs_real.mm_state = packbuf[21];//主推进电机状态
                                        //ap2gcs_real.rud_p = packbuf[22];//方向舵机控制P增益
                                        //ap2gcs_real.rud_i = packbuf[23];//方向舵机控制I增益
                                        //ap2gcs_real.spare1 = packbuf[24];//预留
                                        //ap2gcs_real.boat_temp1 = packbuf[25];//[度]，艇内1号点温度
                                        //ap2gcs_real.boat_temp2 = packbuf[26];//[度]，艇内2号点温度
                                        //ap2gcs_real.boat_humi = packbuf[27];//[%]，艇内湿度
                                        //ap2gcs_real.wpno = packbuf[28];//下一航点编号，0xff表示是GCS发送的新航点
                                        //ap2gcs_real.spare2 = packbuf[29];





                                        //wangbo
                                        ap2gcs_real.lng = BitConverter.ToUInt32(packbuf, 0);//[度*0.00001]
                                        ap2gcs_real.lat = BitConverter.ToUInt32(packbuf, 4);//[度*0.00001]
                                        ap2gcs_real.spd = BitConverter.ToUInt32(packbuf, 8);//[Knot*0.01]，实时航速
                                        ap2gcs_real.dir = BitConverter.ToInt16(packbuf, 12);//[度*0.01]，航向
                                        ap2gcs_real.pitch = BitConverter.ToInt16(packbuf, 14);//[度*0.01]，俯仰
                                        ap2gcs_real.roll = BitConverter.ToInt16(packbuf, 16);//[度*0.01]，滚转
                                        ap2gcs_real.yaw = BitConverter.ToInt16(packbuf, 18);//[度*0.01]，偏航
                                        ap2gcs_real.moo_pwm = packbuf[20];//主电机启停舵机PWM 0-255
                                        ap2gcs_real.mbf_pwm = packbuf[21];//主电机前进后退舵机PWM 0-255
                                        ap2gcs_real.rud_pwm = packbuf[22];//方向舵舵机PWM 0-255
                                        ap2gcs_real.mm_state = packbuf[23];//主推进电机状态
                                        ap2gcs_real.rud_p = packbuf[24];//方向舵机控制P增益
                                        ap2gcs_real.rud_i = packbuf[25];//方向舵机控制I增益
                                        ap2gcs_real.spare1 = packbuf[26];//预留
                                        ap2gcs_real.boat_temp1 = packbuf[27];//[度]，艇内1号点温度
                                        ap2gcs_real.boat_temp2 = packbuf[28];//[度]，艇内2号点温度
                                        ap2gcs_real.boat_humi = packbuf[29];//[%]，艇内湿度
                                        ap2gcs_real.wpno = packbuf[30];//下一航点编号，0xff表示是GCS发送的新航点
                                        ap2gcs_real.spare2 = packbuf[31];






                                        //实时数据接收计数
                                        gbl_var.ap2gcs_real_cnt++;
                                    }
                                    else if (comA_recvpacket.type == ID_AP2GCS_CMD)//AP-->GCS命令回传包
                                    {
                                        ap2gcs_cmd_back.cmd_state = packbuf[0];
                                        ap2gcs_cmd_back.cmd_test = packbuf[1];
                                        ap2gcs_cmd_back.cmd_manu = packbuf[2];
                                        ap2gcs_cmd_back.cmd_auto = packbuf[3];
                                        ap2gcs_cmd_back.cmd_rkt = packbuf[4];
                                        ap2gcs_cmd_back.cmd_aws = packbuf[5];
                                        ap2gcs_cmd_back.cmd_mot = packbuf[6];
                                        ap2gcs_cmd_back.cmd_flag = packbuf[7];
                                        ap2gcs_cmd_back.moo_pwm = packbuf[8];
                                        ap2gcs_cmd_back.mbf_pwm = packbuf[9];
                                        ap2gcs_cmd_back.rud_pwm = packbuf[10];
                                        ap2gcs_cmd_back.rud_p = packbuf[11];
                                        ap2gcs_cmd_back.rud_i = packbuf[12];
                                        ap2gcs_cmd_back.wpno = packbuf[13];
                                        if ((ap2gcs_cmd_back.cmd_state == gcs2ap_cmd.cmd_state)
                                            && (ap2gcs_cmd_back.cmd_state == 0x3))//测试状态时清限位设置命令
                                        {
                                            //如果D2-D0不为零，且D5-D3不为零，则表明上次发送的是舵机位置标定值，
                                            //此时，记录该位置并将该指令清除
                                            if (((ap2gcs_cmd_back.cmd_test & 0x7) != 0) && ((ap2gcs_cmd_back.cmd_test&0x38) != 0))
                                            {
                                                if (ap2gcs_cmd_back.cmd_test == 0x9)
                                                {
                                                    gbl_var.motor_on_pwm = ap2gcs_cmd_back.moo_pwm;
                                                }
                                                if (ap2gcs_cmd_back.cmd_test == 0x11)
                                                {
                                                    gbl_var.motor_off_pwm = ap2gcs_cmd_back.moo_pwm;
                                                }
                                                if (ap2gcs_cmd_back.cmd_test == 0x1a)
                                                {
                                                    gbl_var.motor_fwd_pwm = ap2gcs_cmd_back.mbf_pwm;
                                                }
                                                if (ap2gcs_cmd_back.cmd_test == 0x22)
                                                {
                                                    gbl_var.motor_bwd_pwm = ap2gcs_cmd_back.mbf_pwm;
                                                }
                                                if (ap2gcs_cmd_back.cmd_test == 0x2c)
                                                {
                                                    gbl_var.rud_left_pwm = ap2gcs_cmd_back.rud_pwm;
                                                }
                                                if (ap2gcs_cmd_back.cmd_test == 0x34)
                                                {
                                                    gbl_var.rud_right_pwm = ap2gcs_cmd_back.rud_pwm;
                                                }
                                                if (ap2gcs_cmd_back.cmd_test == 0x3c)
                                                {
                                                    gbl_var.rud_mid_pwm = ap2gcs_cmd_back.rud_pwm;
                                                }
                                                gcs2ap_cmd_new.cmd_test &= 0xc7;//将位置设置命令清除
                                                gcs2ap_cmd_new.cmd_flag &= 0xf7;//清回传命令
                                                gbl_var.send_req_cnt++;
                                                gbl_var.send_cmd_req = true;
                                            }
                                        }
                                        
                                    }
                                    else if (comA_recvpacket.type == ID_AP2GCS_WP)//AP-->GCS航点回传包
                                    {
                                        ap2gcs_wp_back.type = packbuf[0];
                                        ap2gcs_wp_back.total = packbuf[1];
                                        ap2gcs_wp_back.no = packbuf[2];
                                        ap2gcs_wp_back.spd = packbuf[3];
                                        ap2gcs_wp_back.lng = BitConverter.ToUInt32(packbuf, 4);//[度*0.00001]
                                        ap2gcs_wp_back.lat = BitConverter.ToUInt32(packbuf, 8);//[度*0.00001]
                                        gbl_var.ap2gcs_wp_cnt++;

                                        //接收正确，可发送下一个航点或者结束发送
                                        if((gcs2ap_wp.no == ap2gcs_wp_back.no)&&(gcs2ap_wp.type == ap2gcs_wp_back.type)
                                            &&(gcs2ap_wp.total == ap2gcs_wp_back.total)&&(gcs2ap_wp.lat == ap2gcs_wp_back.lat)
                                            &&(gcs2ap_wp.lng == ap2gcs_wp_back.lng)&&(gcs2ap_wp.spd == ap2gcs_wp_back.spd))
                                        {
                                            if ((gcs2ap_wp.type == 1) && ((gcs2ap_wp.no + 1) < gcs2ap_wp.total))//全部航点还没有都发送完
                                            //if ((gcs2ap_wp.type == 1) && (() <= gcs2ap_wp.total))//全部航点还没有都发送完
                                            {
                                                //firstWp++;
                                                gcs2ap_wp.no++;
                                                gcs2ap_wp.spd = Convert.ToByte(totalWPlist[gcs2ap_wp.no].Alt * 100);
                                                gcs2ap_wp.lng = Convert.ToUInt32(totalWPlist[gcs2ap_wp.no].Lng * 10000);
                                                gcs2ap_wp.lat = Convert.ToUInt32(totalWPlist[gcs2ap_wp.no].Lat * 10000);
                                                gbl_var.send_req_cnt++;
                                                gbl_var.send_wp_req = true;
                                            }
                                            else
                                            {
                                                gcs2ap_wp.type = 0x0;//不是要发送全部航点，或者已经全部发送完毕，则不再发送                                                
                                            }
                                        
                                        }
                                        else//接收错误，需要重发
                                        {
                                            //to be done
                                        }

                                        
                                    }
                                    else if (comA_recvpacket.type == ID_AP2GCS_ACK)//AP-->GCS接收确认包
                                    {
                                        ap2gcs_ack.type = packbuf[0];//接收数据包类型
                                        ap2gcs_ack.cnt = packbuf[1];//接收数据包编号
                                        ap2gcs_ack.state = packbuf[2];//接收数据包状态
                                        ap2gcs_ack.spare = packbuf[3];
                                        ap2gcs_ack.hhmmss = BitConverter.ToUInt32(packbuf, 4);//接收数据包时间
                                        gbl_var.ap2gcs_ack_cnt++;
                                    }
                                    else if (comA_recvpacket.type == ID_AP2GCS_AWS)//AP-->GCS气象站数据包
                                    {
                                        ap2gcs_aws.hhmmss = BitConverter.ToUInt32(packbuf, 0);//发送数据包时间
                                        ap2gcs_aws.lng = BitConverter.ToUInt32(packbuf, 4);//[度*0.00001]
                                        ap2gcs_aws.lat = BitConverter.ToUInt32(packbuf, 8);//[度*0.00001]
                                        ap2gcs_aws.temp = BitConverter.ToInt16(packbuf, 12);//[度*0.01]
                                        ap2gcs_aws.dewtemp = BitConverter.ToInt16(packbuf, 14);//[度*0.01]
                                        ap2gcs_aws.humi = BitConverter.ToUInt16(packbuf, 16);//[*0.01]
                                        ap2gcs_aws.airpress = BitConverter.ToUInt16(packbuf, 18);//[*0.01]
                                        ap2gcs_aws.winddir = BitConverter.ToInt16(packbuf, 20);//[*0.01]
                                        ap2gcs_aws.windspd = BitConverter.ToInt16(packbuf, 22);//[*0.01]
                                        gbl_var.ap2gcs_aws_cnt++;
                                    }
                                }
                                comA_recvpacket.state = RECV_HEAD1;
                                packbuflen = 0;

                                break;
                        }
                    }
                }
                catch
                {
                    if (!comPortA.IsOpen)
                    {
                        while (comAListening) Application.DoEvents();//打开时点击，则关闭串口
                        comAClosing = true;
                        comPortA.Close();
                        cbxACOMPort.Enabled = true;
                        cbxABaudRate.Enabled = true;
                        btnPortAOpenClose.Text = "打开";
                        statusPortAName.Text = "串口A: ";
                    }
                }
                finally
                {
                    comAListening = false;//可以关闭串口
                }
            }
        }

        /// <summary>
        /// 生成数据包并通过串口发送。数据包格式:
        /// 0xAA | 0x55 | len(0-255) | cnt(0-255) | sysid(255) | type(0-255) | data(length = len) | checksum 
        /// sysid: GCS:0xf, AP: 0x1.
        /// type: GCS->AP: x1: GCS2AP_WP; x2: GCS2AP_CMD; x3: GCS2AP_LNK; 
        ///       AP->GCS: x11: AP2GCS_REAL; x12: AP2GCS_CMD; x13: AP2GCS_WP; x14: AP2GCS_ACK; x18:AP2GCS_AWS
        /// </summary>
        void generatePacket(byte messageType, byte[] buf, int len)
        {
            if (!comPortA.IsOpen) return;

            lock (comASendlock)
            {
                byte[] packet = new byte[6+len+1];//数据包长度
                packet[0] = 0xaa;
                packet[1] = 0x55;
                packet[2] = (byte)len;
                packet[3] = (byte)comAsendPacketCnt;
                comAsendPacketCnt++;
                packet[4] = SYSID_GCS;
                packet[5] = messageType;

                //把indata中的数据写到Mavlink包的payload区
                int i = 6;
                foreach (byte b in buf)
                {
                    packet[i] = b;
                    i++;
                }

                //改为校验和
                i = 0;
                byte checksum = 0;
                for (i = 0; i < len + 6; i++)
                {
                    checksum += packet[i];
                }
                i = len + 6;
                packet[i] = (byte)(checksum & 0xff);
                i += 1;

                if (comPortA.IsOpen)
                {
                    comPortA.Write(packet, 0, i);//发送数据包，从0字节开始，长度为i,即包长度
                    comAsendCount += len;
                }
            }
        }

        void Send_GCS2AP_CMD()
        {
            int i = 0;
            bool cmp_equal = true;
            int _size = Marshal.SizeOf(gcs2ap_cmd);
            //先比较已经发送给AP的数据和当前修改后的数据是否一致，若不一致则说明有新命令，需要发送数据包
            byte[] _cur = MyConverter.StructToByte(gcs2ap_cmd, _size);
            byte[] _new = MyConverter.StructToByte(gcs2ap_cmd_new, _size);
            for (i = 0; i < _size; i++)
            {
                if (_cur[i] != _new[i])
                {
                    cmp_equal = false;
                    break;
                    
                };
            }
            //两个包不一致，发送新数据包，并用新数据包替换老数据包
            //if (!cmp_equal) //不检查，每次都触发发送
            {
                gcs2ap_cmd = gcs2ap_cmd_new;
                generatePacket(ID_GCS2AP_CMD, _new, _size);//输出
            }
        }

        void Send_GCS2AP_WP()
        {
            int _size = Marshal.SizeOf(gcs2ap_wp);
            byte[] _wp = MyConverter.StructToByte(gcs2ap_wp, _size);
            generatePacket(ID_GCS2AP_WP, _wp, _size);//输出
        }

        /// <summary>
        /// 在地图上添加一个航点标志
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="lng"></param>
        /// <param name="lat"></param>
        /// <param name="alt"></param>
        private void addpolygonmarker(string tag, double lat, double lng, double alt, Color? color)
        {
            try
            {
                PointLatLng point = new PointLatLng(lat, lng);
                GMapMarkerWP m = new GMapMarkerWP(point, tag);
                m.ToolTipMode = MarkerTooltipMode.OnMouseOver;
                m.ToolTipText = "Alt: " + alt.ToString("0");
                m.Tag = tag;
                markersOverlay.Markers.Add(m);//添加标志
            }
            catch (Exception) { }
        }

        private void MMItemMPlan_Click(object sender, EventArgs e)
        {
            gbl_var.bRoutePlan = !gbl_var.bRoutePlan;
        }

        private void gMapControl_MouseMove(object sender, MouseEventArgs e)
        {
            PointLatLng point = gMapControl.FromLocalToLatLng(e.X, e.Y);
            double current2home_lng_m;
            double current2home_lat_m;
            double current2home_m;
            double current2home_m2;
            double current2home_m3;
            string NS;
            string WE;
            //鼠标移动时，在地图左上角显示当前坐标和距离HOME的距离
            labelLocLatLng.Text = point.Lat.ToString("0.00000") + "," + point.Lng.ToString("0.00000");
            //若有航点，则在鼠标移动时显示当前鼠标位置与第一个航点之间的距离
            if (totalWPlist.Count > 0)
            {
                //纬度上的距离（即东西距离）
                tmp_point_4_calc.Lng = totalWPlist[0].Lng;
                tmp_point_4_calc.Lat = point.Lat;
                current2home_lat_m = totalWPlist[0].GetDistance(tmp_point_4_calc);
                if (point.Lat > totalWPlist[0].Lat) NS = "N";
                else NS = "S";
                //经度上的距离（即南北距离）
                tmp_point_4_calc.Lng = point.Lng;
                tmp_point_4_calc.Lat = totalWPlist[0].Lat;
                current2home_lng_m = totalWPlist[0].GetDistance(tmp_point_4_calc);
                if (point.Lng > totalWPlist[0].Lng) WE = "E";
                else WE = "W";
                //直线距离
                tmp_point_4_calc.Lat = point.Lat;
                current2home_m = totalWPlist[0].GetDistance(tmp_point_4_calc);
                current2home_m2 = totalWPlist[0].GetDistance2(tmp_point_4_calc);
                current2home_m3 = totalWPlist[0].GetBearing(tmp_point_4_calc);
                //显示
                labelDist2Home.Text = current2home_m.ToString("0") + " (" + NS + current2home_lat_m.ToString("0")
                    + "," + WE + current2home_lng_m.ToString("0") + ")";
                label3.Text = current2home_m2.ToString("0");
                label4.Text = current2home_m3.ToString("0");
            }

            //如果是在航点规划状态，则若某个航点被选(即在某个航点上点击了鼠标左键)，则可以被拖动
            if (gbl_var.bRoutePlan)
            {
                if (gbl_var.markerselected)//航点被选
                {
                    //该航点的GPS坐标随着鼠标位置而变化
                    totalWPlist[actWP_index].Lat = gMapControl.FromLocalToLatLng(e.X, e.Y).Lat;
                    totalWPlist[actWP_index].Lng = gMapControl.FromLocalToLatLng(e.X, e.Y).Lng;
                    actWP_marker.Position = gMapControl.FromLocalToLatLng(e.X, e.Y);
                }
                else
                {
                }
            }
        }

        private void gMapControl_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)//点击鼠标左键
            {
                if (gbl_var.bRoutePlan)//若是航点规划状态，则可以修改航点。以后要考虑在线修改
                {
                    //如果在航点处，则标记航点被选，且给出航点在航点表中的位置
                    if (gbl_var.markerentered)
                    {
                        gbl_var.markerselected = true;
                        //先找到航点链表中的相应航点下标
                        actWP_index = getWPindex(actWP_marker.Tag.ToString());//feiqing 总报错需检查
                    }
                }
            }
            if (e.Button == MouseButtons.Right)//鼠标右键出菜单
            {
                currentPosition = gMapControl.FromLocalToLatLng(e.X, e.Y);
            }
        }

        private void gMapControl_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)//点击鼠标左键
            {
                if (gbl_var.bRoutePlan)//航点规划状态时：加航点
                {
                    if (gbl_var.markerselected)//如果是移动航点，则不需要做增加航点的工作，只是重新画航线即可
                    {
                    }
                    else//如果是增加航点，则
                    {
                        //将本点追加入航点链表
                        if (totalWPlist.Count == 0)
                        {
                            totalWPlist.Add(new PointLatLngAlt(gMapControl.FromLocalToLatLng(e.X, e.Y).Lat,
                                gMapControl.FromLocalToLatLng(e.X, e.Y).Lng, default_WP_spd, "H"));
                        }
                        else
                        {
                            totalWPlist.Add(new PointLatLngAlt(gMapControl.FromLocalToLatLng(e.X, e.Y).Lat,
                                gMapControl.FromLocalToLatLng(e.X, e.Y).Lng, default_WP_spd, totalWPlist.Count.ToString()));
                        }
                        //在地图上标出本航点
                        addpolygonmarker((totalWPlist.Count - 1).ToString(), gMapControl.FromLocalToLatLng(e.X, e.Y).Lat,
                            gMapControl.FromLocalToLatLng(e.X, e.Y).Lng, default_WP_spd, null);
                        //重新画出全部航点路径。因为添加新航点后，需要删除原返航路径，改为从新航点返航，所以干脆全部重画
                        //以后也可以改为仅删除原返航路径，然后画新航点的两条路径（到达和返航）
                    }
                    ReDrawAllRoute();
                }
            }
            if (e.Button == MouseButtons.Right)//鼠标右键出菜单
            {
            }

            gbl_var.markerselected = false;
        }

        /// <summary>
        /// 在两个规划航点之间画一条直线路径
        /// </summary>
        /// <param name="point_start"></param>
        /// <param name="point_end"></param>
        private void DrawLineLinkTwoWP(PointLatLng point_start, PointLatLng point_end)
        {
            List<PointLatLng> points;
            GMapPolygon line;
            points = new List<PointLatLng>();
            points.Add(point_start);
            points.Add(point_end);
            line = new GMapPolygon(points, "");
            line.Stroke = new Pen(Color.Yellow, 4);
            markersOverlay.Polygons.Add(line);
        }
        /// <summary>
        /// 在两个实时飞行点之间画一条直线，用于画出实时航路
        /// </summary>
        /// <param name="point_start"></param>
        /// <param name="point_end"></param>
        private void DrawLineLinkTwoRealFlyPoint(PointLatLng point_start, PointLatLng point_end)
        {
            List<PointLatLng> points;
            GMapPolygon line;
            points = new List<PointLatLng>();
            points.Add(point_start);
            points.Add(point_end);
            line = new GMapPolygon(points, "");
            line.Stroke = new Pen(Color.Green, 2);
            realRouteOverlay.Polygons.Add(line);
        }
        /// <summary>
        /// 画出连接全部航点的航路（直线型）
        /// </summary>
        private void ReDrawAllRoute()
        {
            //清除多边形
            markersOverlay.Polygons.Clear();
            //然后重新画航点间直线
            for (int i = 0; i < totalWPlist.Count; i++)
            {
                if (i == totalWPlist.Count - 1)
                    //画最后一个航点到第一个航点的直线
                    DrawLineLinkTwoWP(totalWPlist[totalWPlist.Count - 1], totalWPlist[0]);
                else DrawLineLinkTwoWP(totalWPlist[i], totalWPlist[i + 1]);
                //else DrawLineLinkTwoRealFlyPoint(totalWPlist[i], totalWPlist[i + 1]);
            }
        }

        /// <summary>
        /// 重画全部航点
        /// </summary>
        private void ReDrawAllWP()
        {
            //重新将各航点做标记，第一个航点为H，其它航点从1顺序编号
            for (int i = 0; i < totalWPlist.Count; i++)
            {
                if (i == 0) totalWPlist[i].Tag = "H";
                else totalWPlist[i].Tag = i.ToString();
            }
            //清除地图上的全部航点标志
            markersOverlay.Markers.Clear();
            //重画全部航点
            for (int i = 0; i < totalWPlist.Count; i++)
            {
                addpolygonmarker(totalWPlist[i].Tag, totalWPlist[i].Lat, totalWPlist[i].Lng, totalWPlist[i].Alt, null);
            }
        }
        /// <summary>
        /// 根据航点的tag标志找到该航点的链表位置下标
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private int getWPindex(string tag)
        {
            for (int i = 0; i < totalWPlist.Count; i++)
            {
                if (totalWPlist[i].Tag == tag) return i;
                if (((totalWPlist[i].Tag == "0") || (totalWPlist[i].Tag == "H"))
                    && ((tag == "0") || (tag == "H")))
                    return 0;
            }
            return -1;
        }
        /// <summary>
        /// 插入航点
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void tSMenuItemInsertWP_Click(object sender, EventArgs e)
        {
            if (!gbl_var.bRoutePlan) return;
            PointLatLngAlt newWP = new PointLatLngAlt();
            //向参数设置画面传递要设置的参数id。id=2表示要设置新插入航点位置
            gbl_var.paramset_id = 2;
            //打开参数设置窗口
            Form FrmSingleParamSet = new FrmSingleParamSet();
            FrmSingleParamSet.Text = "设置插入位置";
            FrmSingleParamSet.ShowDialog();
            //插入操作
            newWP.Lat = currentPosition.Lat;
            newWP.Lng = currentPosition.Lng;
            newWP.Alt = default_WP_spd;
            newWP.Tag = (actWP_index + 1).ToString();
            totalWPlist.Insert(actWP_index + 1, newWP);//改为在之前插入
            ReDrawAllWP();//重画全部航点
            ReDrawAllRoute();//重画全部路径
            gbl_var.markerselected = false;
        }
        /// <summary>
        /// 删除指定航点
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void tSMenuItemDeleteWP_Click(object sender, EventArgs e)
        {
            //找到指定航点，并删除
            if (!gbl_var.bRoutePlan) return;
            for (int i = 0; i < totalWPlist.Count; i++)
            {
                if (totalWPlist[i].Tag == actWP_marker.Tag.ToString())
                {
                    totalWPlist.RemoveAt(i);
                    break;
                }
            }
            ReDrawAllWP();//重画全部航点
            ReDrawAllRoute();//重画全部路径
        }

        /// <summary>
        /// 显示航路规划列表
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void tSMenuItemGrid_Click(object sender, EventArgs e)
        {
            Form FrmFlightPlanList = new FrmFlightPlanList();
            FrmFlightPlanList.ShowDialog();
            ReDrawAllWP();
        }
        /// <summary>
        /// 清空航路规划任务数据
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void tSMenuItemClearTask_Click(object sender, EventArgs e)
        {
            totalWPlist.Clear();
            ReDrawAllWP();
            ReDrawAllRoute();
            actWP_marker = null;
            gbl_var.markerentered = false;
            gbl_var.markerselected = false;
        }

        private void MMItemConfig_MouseHover(object sender, EventArgs e)
        {
            if (gbl_var.bRoutePlan) MMItemMPlan.Text = "退出航点规划";
            else MMItemMPlan.Text = "进入航点规划";
        }

        private void gMapControl_OnMarkerLeave(GMapMarker item)
        {
            //如果鼠标没有在某个航点的上方，则点击鼠标右键时进制删除航点和修改高度
            tSMenuItemDeleteWP.Enabled = false;
            tSMenuItemInsertWP.Enabled = true;
            //没有进入航点局域
            gbl_var.markerentered = false;
        }

        private void gMapControl_OnMarkerEnter(GMapMarker item)
        {
            tSMenuItemDeleteWP.Enabled = true;
            tSMenuItemInsertWP.Enabled = false;
            //进入航点区域
            gbl_var.markerentered = true;
            //记录进入的航点，作为当前活动航点
            actWP_marker = item;
        }

        private void MMItemMPortCfg_Click(object sender, EventArgs e)
        {

        }

        private void label20_Click(object sender, EventArgs e)
        {

        }

        private void 高德地图ToolStripMenuItem_Click(object sender, EventArgs e)
        {
            gMapControl.MapProvider = GMap.NET.MapProviders.AMapProvider.Instance;
            statusMapProvider.Text = "高德地图";
        }

        private void 高德卫星地图ToolStripMenuItem_Click(object sender, EventArgs e)
        {
            gMapControl.MapProvider = GMap.NET.MapProviders.AMapSateliteProvider.Instance;
            statusMapProvider.Text = "高德卫星地图";
        }

        /// <summary>
        /// 将当前GPS坐标作为回家的坐标
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnSetHome_Click(object sender, EventArgs e)
        {
            if ((ap2gcs_real.lat > 20.0) && (ap2gcs_real.lng > 100.0))
            {
                homePos.Lat = Convert.ToDouble(ap2gcs_real.lat) * 0.00001;
                homePos.Lng = Convert.ToDouble(ap2gcs_real.lng) * 0.00001;
            }
            else
            {
                homePos.Lat = HUAINAN_LAT;
                homePos.Lng = HUAINAN_LNG;
                ap2gcs_real.lat = Convert.ToUInt32(homePos.Lat * 100000.0);
                ap2gcs_real.lng = Convert.ToUInt32(homePos.Lng * 100000.0);
            }
            gMapControl.Position = homePos;
            gMapControl.Zoom = 16;
            totalWPlist[0].Lng = homePos.Lng;
            totalWPlist[0].Lat = homePos.Lat;
            ReDrawAllWP();//重画全部航点
            ReDrawAllRoute();//重画全部路径
        }

        private void FrmGCSMain_FormClosing(object sender, FormClosingEventArgs e)
        {
        }

        private void btnPortARefresh_Click(object sender, EventArgs e)
        {
            if (comPortA.IsOpen)
            {
            }
            else//串口没有打开的情况下允许重新搜索串口
            {
                cbxACOMPort.Items.Clear();
                ports = SerialPort.GetPortNames();//获取可用串口
                if (ports.Length > 0)//有串口可用
                {
                    for (int i = 0; i < ports.Length; i++)
                    {
                        cbxACOMPort.Items.Add(ports[i]);//下拉控件里添加可用串口
                    }
                    cbxACOMPort.SelectedIndex = 0;
                }
                else//未检测到串口
                {
                    cbxACOMPort.Text = "None";
                }
            }
        }

        private void btnPortAOpenClose_Click(object sender, EventArgs e)
        {
            if (comPortA.IsOpen)
            {
                comAClosing = true;
                while (comAListening) Application.DoEvents();//打开时点击，则关闭串口
                comPortA.Close();
                cbxACOMPort.Enabled = true;
                cbxABaudRate.Enabled = true;
                btnPortAOpenClose.Text = "打开";
            }
            else
            {
                if ((comPortA.PortName != "None") && (comPortA.PortName != null))
                {
                    comPortA.PortName = cbxACOMPort.Text.Trim();//设置串口名
                    comPortA.BaudRate = Convert.ToInt32(cbxABaudRate.Text.Trim());//设置串口的波特率
                    comPortA.DataBits = 8;//设置数据位
                    comPortA.StopBits = StopBits.One;
                    comPortA.Parity = Parity.None;
                    comPortA.ReadTimeout = 5000;//[ms]
                    comPortA.WriteTimeout = 5000;//[ms]
                    comPortA.ReadBufferSize = 1024;
                    comPortA.WriteBufferSize = 1024;
                    comPortA.Open();//打开串口
                }
                else
                {
                    MessageBox.Show("请检查串口配置", "提示");
                }
                if (comPortA.IsOpen)
                {
                    cbxACOMPort.Enabled = false;
                    cbxABaudRate.Enabled = false;
                    comAClosing = false;//等待关闭串口状态改为false 
                    btnPortAOpenClose.Text = "关闭";
                }
            }
        }


        private void trBarTurnMotor_Scroll(object sender, EventArgs e)
        {
            teBoxTurnMotor.Text = Convert.ToString(trBarTurnMotor.Value);
        }


        public static byte[] ConvertDoubleToByteArray(double d)
        {
            return BitConverter.GetBytes(d);
        }

        public static double ConvertByteArrayToDouble(byte[] b)
        {
            return BitConverter.ToDouble(b,0);
        }

        private void btnSimuSail_Click(object sender, EventArgs e)
        {
            if(gbl_var.bSimuState)//进入模拟飞行状态，用于程序调试和测试
            {
                gbl_var.bSimuSailing = true;
            }
        }

        /// <summary>
        /// 飞机当前的位置
        /// </summary>
        PointLatLngAlt realpos_now = new PointLatLngAlt();
        /// <summary>
        /// 上一次显示时的飞行位置
        /// </summary>
        PointLatLngAlt realpos_prev = new PointLatLngAlt();
        /// <summary>
        /// 本时段实时飞行路径起点
        /// </summary>
        PointLatLng realroute_start;
        /// <summary>
        /// 本时段实时飞行路径终点
        /// </summary>
        PointLatLng realroute_end;
        /// <summary>
        /// 当前实时飞行目标航点
        /// </summary>
        int real_tar_WP = 0;//默认当前目标航点
        GMapMarker realVehicle;

        /// <summary>
        /// 飞行器在地图上的实时显示
        /// </summary>        
        private void SailDisplay()
        {
            if (totalWPlist.Count < 1) return;
            if (gbl_var.bSimuState)//模拟飞行显示
            {
                if (totalWPlist.Count == 1)//仅有一个设定航点，则飞机位于航点处
                {
                    realpos_now.Lat = totalWPlist[0].Lat;
                    realpos_now.Lng = totalWPlist[0].Lng;
                    realpos_now.Alt = totalWPlist[0].Alt;
                    realroute_start = realpos_now;
                    real_tar_WP = 0;
                }
                else if (!gbl_var.bSimuSailing)//非模拟飞行状态时，将飞机的当前位置设置为在航点0，下一个航点为1
                {
                    realpos_now.Lat = totalWPlist[0].Lat;
                    realpos_now.Lng = totalWPlist[0].Lng;
                    realpos_now.Alt = totalWPlist[0].Alt;
                    realroute_start = realpos_now;
                    real_tar_WP = 1;
                }
                else //航行状态
                {
                    //查找目标航点
                    for (int i = real_tar_WP; i < totalWPlist.Count; i++)
                    {
                        if (totalWPlist[i].GetDistance(realpos_now) < 10.0)//[m]如果离某个航点非常近，则目标是下一个航点
                        {
                            if (i == (totalWPlist.Count - 1)) real_tar_WP = 0;
                            else real_tar_WP = i + 1;
                            break;
                        }
                    }
                    double tmp_angle = realpos_now.GetBearing(totalWPlist[real_tar_WP]);
                    double tmp_delta_lat = 0.0001 * Math.Abs(Math.Cos(tmp_angle * Math.PI / 180));//每次移动0.0001(默认飞行速度约=10.0m/s)
                    double tmp_delta_lng = 0.0001 * Math.Abs(Math.Sin(tmp_angle * Math.PI / 180));

                    if (realpos_now.Lat > (totalWPlist[real_tar_WP].Lat + tmp_delta_lat)) realpos_now.Lat -= tmp_delta_lat;
                    else if (realpos_now.Lat < (totalWPlist[real_tar_WP].Lat - tmp_delta_lat)) realpos_now.Lat += tmp_delta_lat;
                    if (realpos_now.Lng > (totalWPlist[real_tar_WP].Lng + tmp_delta_lng)) realpos_now.Lng -= tmp_delta_lng;
                    else if (realpos_now.Lng < (totalWPlist[real_tar_WP].Lng - tmp_delta_lng)) realpos_now.Lng += tmp_delta_lng;
                    if (realpos_now.Alt > (totalWPlist[real_tar_WP].Alt + 1.0)) realpos_now.Alt -= 1.0;//[m/s]默认爬升率=1m/s
                    else if (realpos_now.Alt < (totalWPlist[real_tar_WP].Alt - 1.0)) realpos_now.Alt += 1.0;//[m/s]爬升率 
                }
            }
            else//真实飞行状态
            {
                if ((ap2gcs_real.lat > 20.0) && (ap2gcs_real.lng > 100.0))
                {
                    realpos_now.Lat = Convert.ToDouble(ap2gcs_real.lat) * 0.00001;
                    realpos_now.Lng = Convert.ToDouble(ap2gcs_real.lng) * 0.00001;
                }
                else
                {
                    realpos_now.Lat = homePos.Lat;
                    realpos_now.Lng = homePos.Lng;
                }
            }
            
            //画出飞行动画
            realVehicleOverlay.Clear();//先清除上次画的动画
            float target_angle = (float)realpos_now.GetBearing(totalWPlist[real_tar_WP]);//计算目标点方向
            float cog_angle = (float)realpos_prev.GetBearing(realpos_now);//计算地速方向
            float heading_angle = target_angle;//机头朝向，应由自驾仪传感器给出
            float nav_angle = target_angle;//导航方向，应由自驾仪计算给出
            realVehicle = new GMapMarkerBoat(realpos_now, heading_angle, cog_angle, nav_angle, target_angle);//画动画
            realVehicleOverlay.Markers.Add(realVehicle);
            //画出实时飞行航路
            realroute_end = realpos_now;
            DrawLineLinkTwoRealFlyPoint(realroute_start, realroute_end);//画实时飞行航路
            realroute_start = realroute_end;//记录当前航点
            realpos_prev.Lat = realroute_end.Lat;//用于计算地速方向
            realpos_prev.Lng = realroute_end.Lng;
            
        }

        private void FrmGCSMain_FormClosed(object sender, FormClosedEventArgs e)
        {
            file_real_w.Close();
            file_real.Close();
        }

        private void ckBoxSimu_Click(object sender, EventArgs e)
        {
            if (ckBoxSimu.Checked) gbl_var.bSimuState = true;
            else gbl_var.bSimuState = false;
        }

        private void main_timer_Tick(object sender, EventArgs e)
        {
            //手柄输出
            byte _pitch, _roll, _yaw, _throttle;
            _pitch = 0;
            _roll = 0;
            _yaw = 0;
            _throttle = 0;
            if (gbl_var.bJoystickInstalled)
            {
                joystick.UpdateStatus();
                _pitch = Convert.ToByte(((65535 - joystick.AxisD) >> 8) & 0xff);
                _roll = Convert.ToByte(((65535 - joystick.AxisC) >> 8) & 0xff);
                _yaw = Convert.ToByte(((65535 - joystick.AxisA) >> 8) & 0xff);
                _throttle = Convert.ToByte(((65535 - joystick.AxisE) >> 8) & 0xff);
            }


            //系统配置栏中操作杆位置显示
            teBox_jsk_pitch.Text = Convert.ToString(_pitch);
            teBox_jsk_throttle.Text = Convert.ToString(_throttle);
            teBox_jsk_yaw.Text = Convert.ToString(_yaw);
            teBox_jsk_roll.Text = Convert.ToString(_roll);
            prBar_jsk_yaw.Value = _yaw;
            prBar_jsk_roll.Value = _roll;
            prBar_jsk_pitch.Value = _pitch;
            prBar_jsk_throttle.Value = _throttle;

            //在主控数据栏的舵机标定位置显示从AP接收到的舵机标定位置
            teBox_jsk_on.Text = Convert.ToString(gbl_var.motor_on_pwm);
            teBox_jsk_off.Text = Convert.ToString(gbl_var.motor_off_pwm);
            teBox_jsk_fwd.Text = Convert.ToString(gbl_var.motor_fwd_pwm);
            teBox_jsk_bwd.Text = Convert.ToString(gbl_var.motor_bwd_pwm);
            teBox_jsk_rudllmt.Text = Convert.ToString(gbl_var.rud_left_pwm);
            teBox_jsk_rudrlmt.Text = Convert.ToString(gbl_var.rud_right_pwm);
            teBox_jsk_rudmid.Text = Convert.ToString(gbl_var.rud_mid_pwm);

            //在主控数据栏的舵机标定位置显示摇杆的数据输入
            prBar_jsk_onoff.Value = _roll;//用滚转来标定启停舵机
            teBox_jsk_onoff.Text = Convert.ToString(prBar_jsk_onoff.Value);
            prBar_jsk_bwdfwd.Value = _pitch;//用俯仰来标定前进后退舵机
            teBox_jsk_bwdfwd.Text = Convert.ToString(prBar_jsk_bwdfwd.Value);
            prBar_jsk_rudlmt.Value = _yaw;//用偏航来标定方向舵舵机
            teBox_jsk_rudlmt.Text = Convert.ToString(prBar_jsk_rudlmt.Value);

            //在主控数据栏的手动遥控位置显示摇杆的数据输入
            prBar_jsk_throttle2.Value = _throttle;
            teBox_jsk_throttle2.Text = Convert.ToString(_throttle);
            //prBar_jsk_yaw2.Value = _yaw;
            //teBox_jsk_yaw2.Text = Convert.ToString(_yaw);
            prBar_jsk_yaw2.Value = _throttle;
            teBox_jsk_yaw2.Text = Convert.ToString(_throttle);

            //AP反馈的舵机当前位置值
            teBox_fb_oo_pwm.Text = Convert.ToString(ap2gcs_real.moo_pwm);
            teBox_fb_bf_pwm.Text = Convert.ToString(ap2gcs_real.mbf_pwm);
            teBox_fb_yaw_pwm.Text = Convert.ToString(ap2gcs_real.rud_pwm);

            //摇杆给出的方向舵位置增益值
            teBoxTurnMotor.Text = Convert.ToString(trBarTurnMotor.Value);
            //AP反馈的方向舵位置增益值
            teBoxTurnMotorFb.Text = Convert.ToString(ap2gcs_real.rud_p);
/*
            //根据油门舵机的位置判断主电机的工作状态，并在手动遥控栏中显示
            if ((_throttle >= 0) && (_throttle < 50))
            {
                gbl_var.mmotor_state = 0x2;
                labelMotorState.Text = "反向"; 
            }
            else if ((_throttle > 180) && (_throttle <= 255))
            {
                gbl_var.mmotor_state = 0x1;
                labelMotorState.Text = "正向"; 
            }
            else
            {
                gbl_var.mmotor_state = 0x0;
                labelMotorState.Text = "停车"; 
            }
*/
            statusPortARecvCnt.Text = comArecvCount.ToString();//接收数据字节数
            statusPortASendCnt.Text = comAsendCount.ToString();//发送数据字节数

            //在手动遥控情况下，当遥控状态或数值变化时，通知发送命令包
            if (gbl_var.run_state == 0x3)//测试状态
            {
                if (checkBoxOnoffAct.Checked)
                {
                    gcs2ap_cmd_new.moo_pwm = Convert.ToByte(prBar_jsk_onoff.Value);
                    gbl_var.send_req_cnt++;
                    gbl_var.send_cmd_req = true;
                }
                if (checkBoxBwdfwdAct.Checked)
                {
                    gcs2ap_cmd_new.mbf_pwm = Convert.ToByte(prBar_jsk_bwdfwd.Value);
                    gbl_var.send_req_cnt++;
                    gbl_var.send_cmd_req = true;
                }
                if (checkBoxRudLmtAct.Checked)
                {
                    gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_rudlmt.Value);
                    gbl_var.send_req_cnt++;
                    gbl_var.send_cmd_req = true;
                }
            }
            else if (gbl_var.run_state == 0x6)//人工遥控状态
            {
                if ((gcs2ap_cmd_new.rud_pwm != Convert.ToByte(prBar_jsk_yaw2.Value))
                    || (gbl_var.mmotor_pwm_out != Convert.ToByte(prBar_jsk_throttle2.Value)))
                {
                    //gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_yaw2.Value);
                    gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_yaw2.Value);
                    gcs2ap_cmd_new.moo_pwm = Convert.ToByte(prBar_jsk_throttle2.Value);
                    gcs2ap_cmd_new.mbf_pwm = Convert.ToByte(prBar_jsk_throttle2.Value);
                    gcs2ap_cmd_new.cmd_manu = gbl_var.mmotor_state;
                    //gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                    gbl_var.send_req_cnt++;
                    gbl_var.send_cmd_req = true;
                }
            }
            else if (gbl_var.run_state == 0x5)//自动状态
            {
                gcs2ap_cmd_new.rud_p = Convert.ToByte(trBarTurnMotor.Value);
                gcs2ap_cmd_new.rud_i = 0;
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }



            //在自动驾驶状态下，当AP控制参数发生变化时，通知发送命令包
            
            //发送数据包的准备和处理
            if (gbl_var.send_req_cnt != gbl_var.send_req_cnt_lst)//当有发送请求,即发送请求累加器变化时，处理发送工作
            {
                //若需要发送命令
                if (gbl_var.send_cmd_req)
                {
                    /*
                    //根据工作状态来确定要发送的数据
                    switch (gbl_var.run_state)
                    {
                        case 0x3://测试状态
                            if (checkBoxOnoffAct.Checked)
                            {
                                gcs2ap_cmd_new.moo_pwm = Convert.ToByte(prBar_jsk_onoff.Value);
                            }
                            if (checkBoxBwdfwdAct.Checked)
                            {
                                gcs2ap_cmd_new.mbf_pwm = Convert.ToByte(prBar_jsk_bwdfwd.Value);
                            }
                            if (checkBoxRudLmtAct.Checked)
                            {
                                gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_rudlmt.Value);
                            }
                            break;
                        case 0x6://人工状态
                            gcs2ap_cmd_new.cmd_manu = gbl_var.mmotor_state;
                            gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_yaw2.Value);
                            break;
                        case 0x5://自动状态
                            gcs2ap_cmd_new.rud_p = Convert.ToByte(trBarTurnMotor.Value);
                            gcs2ap_cmd_new.rud_i = 0;
                            break;
                        case 0xa0://紧急停车
                            //不做任何处理，只是把紧急停车要求发给AP，由AP来完成相关工作
                            break;
                    }
                    */
                    Send_GCS2AP_CMD();                
                }
                gbl_var.send_cmd_req = false;
                if (gbl_var.send_wp_req)
                {
                    Send_GCS2AP_WP();              
                }
                gbl_var.send_wp_req = false;
            
            }
            gbl_var.send_req_cnt_lst = gbl_var.send_req_cnt;




            //时间间隔为TIMER_DISP
            //包括：飞行路径及飞行动画显示、基本状态(如：心跳，通信状态，地面站状态)显示
            if (gbl_var.main_timer_interval < 50) gbl_var.main_timer_interval = 50;
            if (gbl_var.main_timer_interval >2000) gbl_var.main_timer_interval = 2000;

            //当收到新实时数据包时，更新显示和保存
            if (gbl_var.ap2gcs_real_cnt != gbl_var.ap2gcs_real_cnt_lst)
            {

                //左侧文本框的数据显示
                teBox_ap_lng.Text = Convert.ToString(ap2gcs_real.lng * 0.00001);
                teBox_ap_lat.Text = Convert.ToString(ap2gcs_real.lat * 0.00001);
                teBox_ap_pitch.Text = Convert.ToString(ap2gcs_real.pitch * 0.01);
                teBox_ap_roll.Text = Convert.ToString(ap2gcs_real.roll * 0.01);
                teBox_ap_yaw.Text = Convert.ToString(ap2gcs_real.yaw * 0.01);
                teBox_ap_spd.Text = Convert.ToString(ap2gcs_real.spd * 0.01);                
                teBox_inboat_t1.Text = Convert.ToString(ap2gcs_real.boat_temp1 * 0.01);
                teBox_inboat_t2.Text = Convert.ToString(ap2gcs_real.boat_temp2 * 0.01);
                teBox_inboat_humi.Text = Convert.ToString(ap2gcs_real.boat_humi * 0.01);

                //右侧仪表和地图上文本数据显示
                panelInstruments1.SetValue((float)(ap2gcs_real.spd * 0.01), 0, (float)(ap2gcs_real.pitch * 0.01),
                    (float)(ap2gcs_real.roll * 0.01));
                labelRealLat.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.lat) * 0.00001);
                labelRealLng.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.lng) * 0.00001);
                /*
                teBox_ap_lng.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.lng) * 0.00001);
                teBox_ap_lat.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.lat) * 0.00001);
                teBox_ap_pitch.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.pitch) * 0.01);
                teBox_ap_roll.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.roll) * 0.01);
                teBox_ap_yaw.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.yaw) * 0.01);
                 */

                //保存实时数据
                file_real_str = Convert.ToString(ap2gcs_real.lng) + "," + Convert.ToString(ap2gcs_real.lat)
                            + "," + Convert.ToString(ap2gcs_real.pitch) + "," + Convert.ToString(ap2gcs_real.roll)
                            + "," + Convert.ToString(ap2gcs_real.yaw) + "," + Convert.ToString(ap2gcs_real.spd)
                            + "," + Convert.ToString(ap2gcs_real.moo_pwm) + "," + Convert.ToString(ap2gcs_real.mbf_pwm)
                            + "," + Convert.ToString(ap2gcs_real.rud_pwm) + "," + Convert.ToString(ap2gcs_real.rud_p)
                            + "," + Convert.ToString(ap2gcs_real.boat_temp1) + "," + Convert.ToString(ap2gcs_real.boat_temp2)
                            + "," + Convert.ToString(gcs2ap_cmd.cmd_state) + "," + Convert.ToString(gcs2ap_cmd.cmd_test)
                            ;
                file_real_w.WriteLine(file_real_str);
            }

            //当收到新气象站数据包时，更新显示和保存
            if (gbl_var.ap2gcs_aws_cnt != gbl_var.ap2gcs_aws_cnt_lst)
            {
                teBox_ws_lng.Text = Convert.ToString(ap2gcs_aws.lng * 0.00001);
                teBox_ws_lat.Text = Convert.ToString(ap2gcs_aws.lat * 0.00001);
                teBox_ws_temp.Text = Convert.ToString(ap2gcs_aws.temp * 0.01);
                teBox_ws_dewtemp.Text = Convert.ToString(ap2gcs_aws.dewtemp * 0.01);
                teBox_ws_humi.Text = Convert.ToString(ap2gcs_aws.humi * 0.01);
                teBox_ws_airpress.Text = Convert.ToString(ap2gcs_aws.airpress * 0.01);
                teBox_ws_winddir.Text = Convert.ToString(ap2gcs_aws.winddir * 0.01);
                teBox_ws_windspd.Text = Convert.ToString(ap2gcs_aws.windspd * 0.01);            
            }
            //不需要快速显示的数据，延长显示周期
            if ((timerCnt % Convert.ToInt32(TIMER_DISP / gbl_var.main_timer_interval)) == 0)
            {
                if (comPortA.IsOpen)
                {
                    statusPortAName.Text = "串口A: " + comPortA.PortName;
                }
                else
                {
                    statusPortAName.Text = "串口A: ";
                }

                if (gbl_var.ap2gcs_real_cnt != gbl_var.ap2gcs_real_cnt_lst)
                {
                    _alarmSound.Play();//放在此处仅用于测试。应放在通信处，当收到数据包时给出提示音
                    statusHeartBeatCnt.Text = "心跳: " + gbl_var.ap2gcs_real_cnt.ToString();
                }
                statusStateDisp.Text = "航路规划:" + gbl_var.bRoutePlan.ToString() + " 模拟飞行:" + gbl_var.bSimuState.ToString();
                //显示航行动画
                SailDisplay();
            }

            labelRealLat.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.lat) * 0.00001);
            labelRealLng.Text = Convert.ToString(Convert.ToDouble(ap2gcs_real.lng) * 0.00001);

            //更新状态确认，以保证下一次的有效更新
            gbl_var.ap2gcs_real_cnt_lst = gbl_var.ap2gcs_real_cnt;
            gbl_var.ap2gcs_aws_cnt_lst = gbl_var.ap2gcs_aws_cnt;

            timerCnt++;
            if (timerCnt > 999999) timerCnt = 0;
        }
        /// <summary>
        /// 测试模式
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnTestMode_Click(object sender, EventArgs e)
        {
            gbl_var.run_state = 0x3;//测试状态
            panelTest.BackColor = tabPage3.BackColor;
            panelManu.BackColor = panel1.BackColor;
            panelAuto.BackColor = panel1.BackColor;
            panelStop.BackColor = panel1.BackColor;
            checkBoxOnoffAct.Checked = false;
            checkBoxBwdfwdAct.Checked = false;
            checkBoxRudLmtAct.Checked = false;
            gcs2ap_cmd_new.cmd_state = 0x3;
            gbl_var.send_req_cnt++;
            gbl_var.send_cmd_req = true;
        }
        /// <summary>
        /// 手动遥控模式
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnManuMode_Click(object sender, EventArgs e)
        {
            gbl_var.run_state = 0x6;//手操状态
            panelTest.BackColor = panel1.BackColor;
            panelManu.BackColor = tabPage3.BackColor;
            panelAuto.BackColor = panel1.BackColor;
            panelStop.BackColor = panel1.BackColor;
            gcs2ap_cmd_new.cmd_state = 0x6;
            gbl_var.send_req_cnt++;
            gbl_var.send_cmd_req = true;
        }

        /// <summary>
        /// 自动驾驶模式
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnAutoMode_Click(object sender, EventArgs e)
        {
            gbl_var.run_state = 0x5;//自驾状态
            panelTest.BackColor = panel1.BackColor;
            panelManu.BackColor = panel1.BackColor;
            panelAuto.BackColor = tabPage3.BackColor;
            panelStop.BackColor = panel1.BackColor;
            gcs2ap_cmd_new.cmd_state = 0x5;
            gbl_var.send_req_cnt++;
            gbl_var.send_cmd_req = true;
        }

        /// <summary>
        /// 紧急停车模式
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnStop_Click(object sender, EventArgs e)
        {
            gbl_var.run_state = 0xa0;//停车状态
            panelTest.BackColor = panel1.BackColor;
            panelManu.BackColor = panel1.BackColor;
            panelAuto.BackColor = panel1.BackColor;
            panelStop.BackColor = tabPage3.BackColor;
            gcs2ap_cmd_new.cmd_state = 0xa0;
            gbl_var.send_req_cnt++;
            gbl_var.send_cmd_req = true;
        }

        /// <summary>
        /// 主电机启动PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnMMStart_Click(object sender, EventArgs e)
        {
            if (checkBoxOnoffAct.Checked)
            {
                gcs2ap_cmd_new.moo_pwm = Convert.ToByte(prBar_jsk_onoff.Value);
                gcs2ap_cmd_new.cmd_test = 0x9;//启动位:test = 00 001 001
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }
        }
        /// <summary>
        /// 主电机停止PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnMMStop_Click(object sender, EventArgs e)
        {
            if (checkBoxOnoffAct.Checked)
            {
                gcs2ap_cmd_new.moo_pwm = Convert.ToByte(prBar_jsk_onoff.Value);
                gcs2ap_cmd_new.cmd_test = 0x11;//停止位:test = 00 010 001
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }
        }
        /// <summary>
        /// 主电机前进PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnMMFwd_Click(object sender, EventArgs e)
        {
            if (checkBoxBwdfwdAct.Checked)
            {
                gcs2ap_cmd_new.mbf_pwm = Convert.ToByte(prBar_jsk_bwdfwd.Value);
                //gcs2ap_cmd_new.cmd_test = 0x1c;//前进位:test = 00 011 010
                //wangbo
                gcs2ap_cmd_new.cmd_test = 0x1a;//前进位:test = 00 011 010
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;


                
            }
        }
        /// <summary>
        /// 主电机后退PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnMMBwd_Click(object sender, EventArgs e)
        {
            if (checkBoxBwdfwdAct.Checked)
            {
                gcs2ap_cmd_new.mbf_pwm = Convert.ToByte(prBar_jsk_bwdfwd.Value);
                gcs2ap_cmd_new.cmd_test = 0x22;//后退前进位:test = 00 100 010
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;


            }
        }
        /// <summary>
        /// 方向舵左满舵PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnRudLMax_Click(object sender, EventArgs e)
        {
            if (checkBoxRudLmtAct.Checked)
            {
                gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_rudlmt.Value);
                gcs2ap_cmd_new.cmd_test = 0x2c;//左满位:test = 00 101 100
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;



            }
        }
        /// <summary>
        /// 方向舵右满舵PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnRudRMax_Click(object sender, EventArgs e)
        {
            if (checkBoxRudLmtAct.Checked)
            {
                gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_rudlmt.Value);
                gcs2ap_cmd_new.cmd_test = 0x34;//右满位:test = 00 110 100
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }
        }
        /// <summary>
        /// 方向舵中位PWM设置按钮
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnRudLMid_Click(object sender, EventArgs e)
        {
            if ((gcs2ap_cmd_new.cmd_state == 0x3) && (checkBoxRudLmtAct.Checked))
            {
                gcs2ap_cmd_new.rud_pwm = Convert.ToByte(prBar_jsk_rudlmt.Value);
                gcs2ap_cmd_new.cmd_test = 0x3c;//中位:test = 00 111 100
                gcs2ap_cmd_new.cmd_flag |= 0x8;//回传命令
            }
            gbl_var.send_req_cnt++;
            gbl_var.send_cmd_req = true;

        }

        private void btnReturn_Click(object sender, EventArgs e)
        {
            gcs2ap_wp.total = 0xff;
            gcs2ap_wp.type = 0;
            gcs2ap_wp.no = 0xff;
            gcs2ap_wp.lat = Convert.ToUInt32(homePos.Lat * 100000.0);
            gcs2ap_wp.lat = Convert.ToUInt32(homePos.Lng * 100000.0);
            //发送数据包

        }

        private void tSMenuItemDownCurWP_Click(object sender, EventArgs e)
        {
            for (int i = 0; i < totalWPlist.Count; i++)
            {
                if (totalWPlist[i].Tag == actWP_marker.Tag.ToString())
                {
                    gcs2ap_wp.no = Convert.ToByte(i);
                    gcs2ap_wp.total = Convert.ToByte(totalWPlist.Count);
                    gcs2ap_wp.type = 0x0;//只发送一个航点
                    gcs2ap_wp.lat = Convert.ToUInt32(totalWPlist[i].Lat*100000);
                    gcs2ap_wp.lng = Convert.ToUInt32(totalWPlist[i].Lng*100000);
                    gcs2ap_wp.spd = Convert.ToByte(totalWPlist[i].Alt*100);
                    gbl_var.send_req_cnt++;
                    gbl_var.send_wp_req = true;
                    break;
                }
            }
        }

        private void tSMenuItemDownAllWP_Click(object sender, EventArgs e)
        {
            gcs2ap_wp.no = Convert.ToByte(0);
            gcs2ap_wp.total = Convert.ToByte(totalWPlist.Count);
            gcs2ap_wp.type = 0x1;//发送全部航点
            gcs2ap_wp.lat = Convert.ToUInt32(totalWPlist[0].Lat * 100000);
            gcs2ap_wp.lng = Convert.ToUInt32(totalWPlist[0].Lng * 100000);
            gcs2ap_wp.spd = Convert.ToByte(totalWPlist[0].Alt * 100);
            gbl_var.send_req_cnt++;
            gbl_var.send_wp_req = true;
        }

        private void prBar_jsk_throttle2_Click(object sender, EventArgs e)
        {

        }

        private void gMapControl_Load(object sender, EventArgs e)
        {

        }

        private void btnOneStep_Click(object sender, EventArgs e)
        {
            ap2gcs_real.lat = ap2gcs_real.lat + 10;
            ap2gcs_real.lng = ap2gcs_real.lng + 10;
        }

        private void btnOneLeft_Click(object sender, EventArgs e)
        {
            ap2gcs_real.lat = ap2gcs_real.lat + 10;
            ap2gcs_real.lng = ap2gcs_real.lng - 10;
 
        }

        private void btnFwd_Click(object sender, EventArgs e)
        {
            if (gbl_var.run_state == 0x6)//人工遥控状态
            {
                gbl_var.mmotor_state = 0x1;
                labelMotorState.Text = "反向";
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }
        }

        private void btnBwd_Click(object sender, EventArgs e)
        {
            if (gbl_var.run_state == 0x6)//人工遥控状态
            {
                gbl_var.mmotor_state = 0x2;
                labelMotorState.Text = "正向";
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }
        }

        private void btnMotStop_Click(object sender, EventArgs e)
        {
            if (gbl_var.run_state == 0x6)//人工遥控状态
            {
                gbl_var.mmotor_state = 0x0;
                labelMotorState.Text = "停车";
                gbl_var.send_req_cnt++;
                gbl_var.send_cmd_req = true;
            }
        }
    }
}
